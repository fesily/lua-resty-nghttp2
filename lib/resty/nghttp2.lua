---
--- Generated by Luanalysis
--- Created by fesil.
--- DateTime: 2022/10/31 10:48
---
local semaphore = require 'ngx.semaphore'
local ffi = require 'ffi'
local session = require 'resty.nghttp2.session'
local http_connect = require 'resty.nghttp2.http_connect'
local logger = require 'resty.nghttp2.logger'
local ffi_string = ffi.string
local tab_insert = table.insert
local tab_new = require 'table.new'
local _M = {}

---@type table<string, nghttp2.session>
local cache_sessions = {}

---@param sess nghttp2.session
local function shutdown(sess, season)
    cache_sessions[sess.uri] = nil
    logger.info("shutdown nghttp2 session:", season)
end

---@class nghttp2.new_options:nghttp2.options
---@field host string
---@field port integer
---@field scheme string
---@field pool string
---@field pool_size integer
---@field backlog boolean
---@field uri string
---@field detach boolean
---@field timeout integer

function _M.connect(opt)
    local sess, err = session.new(opt)
    if not sess then
        return nil, err
    end
    sess.tcpsock:settimeout(opt.timeout or 10000)

    local ok, err = http_connect(sess, opt)
    if not ok then
        return nil, err
    end

    local th1, th2 = sess:on_connection()
    if not opt.detach then
        cache_sessions[sess.uri] = sess
    end
    return sess, nil, th1, th2
end

local function connect(p, opt, sem, result)
    if p then
        result[2] = "nginx exiting"
        return
    end

    local sess, err, th1, th2 = _M.connect(opt)
    if not sess then
        result[2] = err
    else
        result[1] = sess
    end
    sem:post()
    if th1 then
        ngx.thread.wait(th1)
        ngx.thread.wait(th2)
    end
end

---@param opt nghttp2.new_options
---@return nghttp2.session?, string?
function _M.new(opt)
    assert(opt.host)
    if not opt.uri then
        if opt.scheme and not opt.port then
            if opt.scheme == "http" then
                opt.port = 80
            elseif opt.scheme == "https" then
                opt.port = 443
            end
        elseif opt.port and not opt.scheme then
            if opt.port == 443 then
                opt.scheme = "https"
            elseif opt.port == 80 then
                opt.scheme = "http"
            end
        end
        assert(opt.scheme)
        assert(opt.port)
        opt.uri = opt.scheme .. "://" .. opt.host .. ":" .. opt.port
    end
    assert(opt.uri, "need uri for cache keys")
    if cache_sessions[opt.uri] then
        return cache_sessions[opt.uri]
    end
    local sem, err = semaphore.new()
    if not sem then
        return nil, err
    end
    opt.on_error = shutdown
    opt.timeout = opt.timeout or 5000

    local result = tab_new(2, 0)
    local ok, err = ngx.timer.at(0, connect, opt, sem, result)
    if not ok then
        return nil, err
    end
    sem:wait(30)

    return result[1], result[2]
end

---@param request nghttp2.request
local function request_on_close(request, season)
    if season then
        logger.info("request_on_close:", season)
        request.close_season = season;
    end
    if request.sem then
        request.sem:post()
    end
end

---@param response nghttp2.response
local function response_data_cb(response, data, len)
    if data then
        response.has_body = true
        response.body = response.body or {}
        tab_insert(response.body, ffi_string(data, len))
    end
end

---@class nghttp2.request_params
---@field method ngx.http.method
---@field uri string
---@field headers nghttp2.headers
---@field body string|function
---@field scheme string
---@field host string
---@field timeout integer

---@param sess nghttp2.session
---@param opts nghttp2.request_params
function _M.request(sess, opts)
    if not opts then
        return nil, 'invalid options'
    end

    if not sess:request_allowed() then
        cache_sessions[sess.uri] = nil
        --please new session
        return nil, "REFUSED_STREAM"
    end

    local sem, err = semaphore.new()
    if not sem then
        return nil, err
    end
    ---@type nghttp2.stream
    local strm
    do
        local method = opts.method or "GET"
        local uri = opts.uri or "/"
        local headers = opts.headers
        local body = opts.body
        local scheme = opts.scheme or "http"
        local host = opts.host or sess.host or "localhost"
        strm, err = sess:submit(scheme, host, uri, method, headers, body)
        if not strm then
            return nil, err
        end
    end
    local request = strm.request
    request.sem = sem
    request.on_close = request_on_close
    local response = strm.response
    response.on_data = response_data_cb
    sem:wait(opts.timeout or 1)
    if request.close_season then
        return nil, request.close_season
    end
    return response
end

return _M
