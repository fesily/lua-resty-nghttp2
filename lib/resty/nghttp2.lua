---
--- Generated by Luanalysis
--- Created by fesil.
--- DateTime: 2022/10/31 10:48
---
local semaphore = require 'ngx.semaphore'
local lib = require 'resty.nghttp2.libnghttp2'
local ffi = require 'ffi'
local base = require 'resty.core.base'
local submit = require 'resty.nghttp2.submit'

local _M = {}
local _mt = {
    __index = _M
}
local subsystem = ngx.config.subsystem
local C = ffi.C
local ngx_lua_ffi_sema_post
if subsystem == 'http' then
    ngx_lua_ffi_sema_post = C.ngx_http_lua_ffi_sema_post

elseif subsystem == 'stream' then
    ngx_lua_ffi_sema_post = C.ngx_stream_lua_ffi_sema_post
end


local errlen = 1024

local function get_error(ctx)
    local buf = base.get_string_buf(errlen)
    local ret = lib.nghttp2_asio_error(ctx, buf, errlen)

    if ret == 0 then
        return ffi.string(buf)
    end
    if ret == 1 then
        return nil
    end
    return "unknown error"
end

local function get_client_error(client)
    local buf = base.get_string_buf(errlen)
    local ret = lib.nghttp2_asio_client_error(client, buf, errlen)
    if ret == 0 then
        return ffi.string(buf)
    end
    if ret == 1 then
        return
    end
    return "unknown error"
end

local idle_tick = 1
local busy_tick = 0.05
local nghttp2_ctx
local function timer(p, ctx)
    if p then return end
    if not nghttp2_ctx then return end
    local count = lib.nghttp2_asio_run(ctx)
    if count == 0 then
        ngx.timer.at(idle_tick, timer, ctx)
    else
        get_error(ctx)
        ngx.timer.at(busy_tick, timer, ctx)
    end
end

function _M.init_ctx()
    if nghttp2_ctx then
        return true
    end
    local ctx = lib.nghttp2_asio_init_ctx(ngx_lua_ffi_sema_post)
    if ctx == nil then
        error('Could not initialize nghttp2_asio_client')
    end
    ffi.gc(ctx, lib.nghttp2_asio_release_ctx)
    ngx.timer.at(busy_tick, timer, ctx)
    nghttp2_ctx = ctx
    return true
end

function _M.release_ctx()
    if not nghttp2_ctx then return end
    nghttp2_ctx = nil
end

function _M.new(uri, connection_timeout, read_timeout)
    if not nghttp2_ctx then
        local ok, err = _M.init_ctx()
        if not ok then return nil, err end
    end
    if not uri then
        return nil, 'uri is required'
    end
    connection_timeout = connection_timeout or 10;
    read_timeout = read_timeout or 10;
    local sem, err = semaphore.new()
    if not sem then
        ngx.log(ngx.ERR, 'Could not create semaphore:', err)
        return true
    end

    local client = lib.nghttp2_asio_client_new(nghttp2_ctx, uri, read_timeout, connection_timeout, sem.sem)
    if client == nil then
        return nil, get_error(nghttp2_ctx)
    end
    ffi.gc(client, lib.nghttp2_asio_client_delete)

    local ok, err = sem:wait(connection_timeout)
    if not ok then return nil, err end
    if not lib.nghttp2_asio_client_is_ready(client) then
        return nil, get_client_error(client)
    end
    return setmetatable({ client = client }, _mt)
end

function _M:new_submit(method, uri, data)
    local handler = lib.nghttp2_asio_submit_new(self.client, method, uri, data, nil)
    if handler == nil then
        return nil, 'can\' create submit'
    end
    ffi.gc(handler, lib.nghttp2_asio_submit_delete)
    return submit.new(handler, nghttp2_ctx, get_error, self.client)
end

return _M
